import math
import random
import os, sys, csv
from datetime import datetime

# python runAndMeasureFiForInputs.py backprop 10 ; cd ../../random-fi-parallel/backprop-fixed-seed/ ; python runFiForInputs.py backprop 10 ; ls

memY = {}
memSDC = {}
noOfThreads = 14
noFiperThread = 100

class Chromosome:
    def __init__(self, bounds, seen_input_sdc):
        global memY
        self.noOfArgs = len(bounds)
        self.seen_input_sdc = seen_input_sdc

        self.x = []
        self.inputString = ""
        for i in range(0, self.noOfArgs):
                #self.x.append(random.randint(bounds[i][0], bounds[i][1]))
                if i == 0:
                        self.x.append(random.randint(bounds[i][0], bounds[i][1]) * 16)
                        self.inputString = self.inputString + str(self.x[i])
                else:
                        self.x.append(random.randint(bounds[i][0], bounds[i][1]))
                        self.inputString = self.inputString + " " + str(self.x[i])

        self.y = 0
        self.cc = 0
        self.sdc = -1.0

    def func(self):
        global memY, memSDC

        # Update values
        self.inputString = ""
        for i in range(0, self.noOfArgs):
                if i == 0:
                        self.inputString = self.inputString + str(self.x[i])
                else:
                        self.inputString = self.inputString + " " + str(self.x[i])

        if self.inputString in memY:
                self.y = memY[self.inputString]
                self.sdc = memSDC[self.inputString]
        else:
                os.system("echo {} > input_list.txt".format(self.inputString))
                os.system("python runFiForInputs.py backprop {}".format(noOfThreads))
                os.system("python getFailureforInputs.py . backprop {} {}".format(noOfThreads, noFiperThread))
                os.system("rm -r backprop-*")

                
                inst_sdc_input2 = {}
                # rep_input = "1000 10"

                try:
                        of = open("overall-output/overall-failure-rates-summary-" + self.inputString.replace(" ", "-") + ".log", 'r')
                        fi_summary = of.readlines()
                        totalFi = int(fi_summary[0].split(":")[1].split("=")[0].split("/")[1])
                        totalSDC = int(fi_summary[0].split(":")[1].split("=")[0].split("/")[0])
                        sdcRate = round(float(fi_summary[0].split(":")[1].split("=")[1].split("%")[0]),4)
                except:
                        self.y = 0.0
                        self.cc = 0
                        self.sdc = -1.0
                        memY[self.inputString] = self.y
                        memSDC[self.inputString] = self.sdc
                        logF = open("ga-output.log", 'a')
                        # logF.write("Evaluating input: " + self.inputString + "; fitness score: " + str(self.y) + "; Code Coverage: " + str(self.cc) + "\n")
                        logF.write("Evaluating input: {}; Fitness Score: {:.6f}; Code Coverage: {:.2f}; SDC Rate: {:.2f}\n".format(self.inputString, self.y, self.cc, self.sdc))
                        logF.write("No FI result for input: {}\n".format(self.inputString))
                
                        now = datetime.now()
                        dt_string = now.strftime("%d/%m/%Y %H:%M:%S")

                        logF.write("**** [TIME] **** : " + str(dt_string) + "\n" )
                        logF.close()
                        return

                with open("per-inst-output/per-inst-sdc-rates-{}-valid.csv".format(self.inputString.replace(" ", "-"))) as fff:
                    reader = csv.reader(fff)
                    next(reader)
                    for row in reader:
                        inst_id = int(row[0])
                        fi_count = int(row[1])
                        sdc_rate = float(row[3])

                        inst_sdc_input2[inst_id] = (sdc_rate, fi_count) 
        
                fitness_score = 0.0
                num_fitness_inputs = 0
                # best_representative_input = "0 0"
                # lowest_sdc_diff = float('inf')
                for cur_inp in self.seen_input_sdc.keys():
                        cur_inp_sdc_abs_diff = 0.0
                        num_insts = 0
                        with open("per-inst-output/per-inst-sdc-rates-{}-valid.csv".format(cur_inp.replace(" ", "-"))) as fff:
                                reader = csv.reader(fff)
                                next(reader)
                                for row in reader:
                                        inst_id = int(row[0])
                                        fi_count = int(row[1])
                                        sdc_rate = float(row[3])

                                        (reference_sdc_rate, reference_fi_count) = inst_sdc_input2[inst_id]
                                        if reference_fi_count == 0 or fi_count == 0:
                                                continue

                                        if reference_sdc_rate == 0.0:
                                                reference_sdc_rate = 0.5
                                        cur_inp_sdc_abs_diff += 100.0 * abs(sdc_rate - reference_sdc_rate) / reference_sdc_rate
                                        # cur_inp_sdc_abs_diff += abs(sdc_rate - reference_sdc_rate)
                                        num_insts += 1

                        if num_insts > 0:
                                cur_inp_sdc_abs_diff /= (1.0 * num_insts)

                        # if cur_inp_sdc_abs_diff < lowest_sdc_diff and cur_inp_sdc_abs_diff > 0.0:
                        #         lowest_sdc_diff = cur_inp_sdc_abs_diff
                        #         best_representative_input = cur_inp

                        fitness_score += cur_inp_sdc_abs_diff
                        num_fitness_inputs += 1
                        # if cur_inp_sdc_abs_diff < 100.0:
                        #         fitness_score = 1.0
                        #         break

                if num_fitness_inputs > 0:
                        fitness_score /= (1.0 * num_fitness_inputs)

                if fitness_score == 0.0:
                        fitness_score = 0.5

                # if best_representative_input == "1000 10" or lowest_sdc_diff > 500.0:
                #         best_representative_input = "0 0"
                        

                self.y = fitness_score
                self.cc = 0
                self.sdc = sdcRate
                memY[self.inputString] = self.y
                memSDC[self.inputString] = self.sdc

        logF = open("ga-output.log", 'a')
        # logF.write("Evaluating input: " + self.inputString + "; fitness score: " + str(self.y) + "\n")
        logF.write("Evaluating input: {}; Fitness Score: {:.6f}; Code Coverage: {:.2f}; SDC Rate: {:.2f}\n".format(self.inputString, self.y, self.cc, self.sdc))
     
        now = datetime.now()
        dt_string = now.strftime("%d/%m/%Y %H:%M:%S")

        logF.write("**** [TIME] **** : " + str(dt_string) + "\n" )
        logF.close()
        

